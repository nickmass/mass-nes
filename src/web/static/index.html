<!DOCTYPE html>
<html style="height:100%; margin: 0; overflow:hidden;" >
    <head>
        <title>NES</title>
        <script src="web.js"></script>
    </head>
    <body style="height:100%;margin:0;" >
        <canvas id="canvas" width="256" height="240" style="width:512px;height:480px;image-rendering: pixelated;"></canvas>
        <p>
            <input type="checkbox" id="enable-audio" /><label for="enable-audio">Enable Audio</label><br/>
            <select id="rom-list">
                <option>Loading....</option>
            </select>
            <span id="pause-message"></span>
            <span id="load-message"></span>
            <br/>
            <table>
                <tr><td><strong>Controls</strong></td></tr>
                <tr><td>Up</td><td>Up Arrow</td></tr>
                <tr><td>Down</td><td>Down Arrow</td></tr>
                <tr><td>Left</td><td>Left Arrow</td></tr>
                <tr><td>Right</td><td>Right Arrow</td></tr>
                <tr><td>A</td><td>Z</td></tr>
                <tr><td>B</td><td>X</td></tr>
                <tr><td>Select</td><td>Shift</td></tr>
                <tr><td>Start</td><td>Enter</td></tr>
                <tr><td>Pause</td><td>Space</td></tr>
            </table><br/>
            <a href="https://github.com/nickmass/mass-nes/tree/master/src/web">Code</a>
        </p>
        <script>
         (function(canvas, romlist, enableAudio, pauseMsg, loadMsg) {
             let gfxCtx = canvas.getContext("2d");
             let audioCtx = new window.AudioContext();
             let keys = [];
             let pause = false;
             let frameDelay = 1;

             function mapKey(key) {
                 switch (key) {
                     case "ArrowUp": return "Up";
                     case "ArrowLeft": return "Left";
                     case "ArrowRight": return "Right";
                     case "ArrowDown": return "Down";
                     case "z": return "A";
                     case "x": return "B";
                     case "Shift": return "Select";
                     case "Enter": return "Start";
                 }

                 return false;
             }

             window.addEventListener('keydown', evt => {
                 let key = mapKey(evt.key);
                 if (key && keys.every(k => k != key)) {
                     keys.push(key);
                 }

                 if (evt.key == " ") {
                     pause = !pause;
                     if (pause) {
                         pauseMsg.innerHTML = "Paused";
                     } else {
                         pauseMsg.innerHTML = "";
                     }
                 }
             });

             window.addEventListener('keyup', evt => {
                 let key = mapKey(evt.key);
                 keys = keys.filter(k => k != key);
             });

             Rust.web.then(web => {
                 web.addEventListener("screen", screen => {
                     let img = gfxCtx.getImageData(0, 0, 256, 240);
                     img.data.set(screen);
                     gfxCtx.putImageData(img, 0, 0);
                 });

                 web.addEventListener("audio", samples => {
                     if (!enableAudio.checked) { return; }
                     let buf = audioCtx.createBuffer(1, samples.length, samples.length * 60);
                     let data = buf.getChannelData(0);
                     data.set(samples);

                     let source = audioCtx.createBufferSource();
                     source.buffer = buf;
                     source.connect(audioCtx.destination);

                     source.start();
                 });

                 let frame = 0;
                 function emuLoop() {
                     if(!pause) {
                         web.run_frame(keys);
                         frame += 1;
                         console.log("Frame", frame);
                     }
                     window.setTimeout(emuLoop, frameDelay);
                 }

                 fetch("roms/romlist.txt")
                     .then(res => res.text())
                     .then(text => {
                         let files = text.split('\n')
                                         .map(line => {
                                             let parts = line.split('=');
                                             if (parts.length != 2) { return false };
                                             return {name: parts[0].trim(), path: parts[1].trim()};
                                         })
                                         .filter(f => f)
                                         .sort((a, b) => {
                                             if (a.name > b.name) { return 1; }
                                             if (a.name < b.name) { return -1; }
                                             return 0;
                                         });

                         let options = files
                             .map(file => {
                                 let elem = document.createElement("option");
                                 elem.innerHTML = file.name;
                                 elem.setAttribute("value", file.path);
                                 return elem;
                             });

                         romlist.removeEventListener('change', selectChange);
                         while (romlist.firstChild) {
                             romlist.removeChild(romlist.firstChild);
                         }

                         let selectElem = document.createElement("option");
                         selectElem.innerHTML = "Select a Rom";
                         romlist.appendChild(selectElem);
                         options.forEach(opt => romlist.appendChild(opt));
                         romlist.addEventListener('change', selectChange);
                     });

                 function selectChange(evt) {
                     loadMsg.innerHTML = "Loading...";
                     let path = evt.target.value;
                     if (path) {
                         return loadRom(path);
                     } else {
                         loadMsg.innerHTML = "";
                         return Promise.resolve();
                     }
                 }

                 function loadRom(path) {
                     return fetch(path)
                         .then(res => res.blob())
                         .then(blob => {
                             return new Promise((resolve, reject) => {
                                 let reader = new FileReader();
                                 reader.addEventListener("loadend", () => resolve(reader.result));
                                 reader.addEventListener("error", () => reject(reader.error));
                                 reader.readAsArrayBuffer(blob);
                             })
                         })
                         .then(rom => {
                             let buf = new Uint8Array(rom);
                             web.load_rom(Array.from(buf));

                             emuLoop();
                             loadMsg.innerHTML = "";
                         })
                         .catch(error => {
                             loadMsg.innerHTML = `Error: ${error}`;
                         });
                 }
             })
         })(document.getElementById("canvas"), document.getElementById("rom-list"), document.getElementById("enable-audio"), document.getElementById("pause-message"), document.getElementById("load-message"));
        </script>
    </body>
</html>
