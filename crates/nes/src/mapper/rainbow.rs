#[cfg(feature = "save-states")]
use nes_traits::SaveState;

#[cfg(feature = "save-states")]
use serde::{Deserialize, Serialize};

use std::rc::Rc;

use super::vrc6::{FreqMode, Pulse, Sawtooth};
use crate::bus::{Address, AddressBus, AndAndMask, AndEqualsAndMask, BusKind, DeviceKind};
use crate::cartridge::INes;
use crate::debug::Debug;
use crate::mapper::Mapper;
use crate::memory::{FixedMemoryBlock, Memory, MemoryBlock};
use crate::ppu::PpuFetchKind;

use super::Nametable;

#[derive(Debug, Copy, Clone)]
enum MemSource {
    Rom,
    Ram,
    Fpga,
}

#[cfg_attr(feature = "save-states", derive(Serialize, Deserialize))]
#[derive(Debug, Clone)]
struct SpriteExtRegs(#[cfg_attr(feature = "save-states", serde(with = "serde_arrays"))] [u8; 64]);

impl std::ops::Deref for SpriteExtRegs {
    type Target = [u8; 64];

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl std::ops::DerefMut for SpriteExtRegs {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
enum PpuRead {
    Sprite,
    Bg,
    ExtBg(u8),
    ExtSprite(u8),
    Nametable,
    Attribute,
    ExtAttribute(u8),
}

#[cfg_attr(feature = "save-states", derive(SaveState))]
pub struct Rainbow {
    #[cfg_attr(feature = "save-states", save(skip))]
    cartridge: INes,
    #[cfg_attr(feature = "save-states", save(skip))]
    debug: Rc<Debug>,
    prg_ram: MemoryBlock,
    chr_ram: Option<MemoryBlock>,
    fpga_ram: FixedMemoryBlock<8>,
    // Storing CIRAM inside mapper greatly simplifies applying window/ext-bg effects
    nt_ram: FixedMemoryBlock<2>,
    prg_mode: u8,
    prg_lo_regs: [u8; 8],
    prg_hi_regs: [u8; 8],
    prg_ram_lo_regs: [u8; 2],
    prg_ram_hi_regs: [u8; 2],
    fpga_ram_reg: u8,
    chr_mode: u8,
    bg_ext_hi: u8,
    nt_bank_regs: [u8; 5],
    nt_mode_regs: [u8; 5],
    fill_tile: u8,
    fill_attr: u8,
    chr_lo_regs: [u8; 16],
    chr_hi_regs: [u8; 16],
    spr_ext_lo: SpriteExtRegs,
    spr_ext_hi: u8,
    ppu_state: PpuState,
    ppu_irq_enabled: bool,
    oam_state: ShadowOam,
    cpu_irq_latch: u16,
    cpu_irq_counter: u16,
    cpu_irq_pending: bool,
    cpu_irq_enable: bool,
    cpu_irq_ack_enable: bool,
    cpu_irq_4011_ack: bool,
    fpga_reader_addr: u16,
    fpga_reader_inc: u8,
    pulse_a: Pulse,
    pulse_b: Pulse,
    sawtooth: Sawtooth,
    audio_enable: bool,
    audio_4011_out: bool,
    master_volume: i16,
    redir_nmi: bool,
    redir_nmi_lo: u8,
    redir_nmi_hi: u8,
    redir_irq: bool,
    redir_irq_lo: u8,
    redir_irq_hi: u8,
    wifi_enable: bool,
    wifi_irq_enable: bool,
    wifi_tx_addr: u8,
    wifi_rx_addr: u8,
    wifi_data_pending: bool,
    window_tile_start: u8,
    window_tile_end: u8,
    window_line_start: u8,
    window_line_end: u8,
    window_tile_scroll: u8,
    window_line_scroll: u8,
    warn_oam: bool,
}

impl Rainbow {
    pub fn new(mut cartridge: INes, debug: Rc<Debug>) -> Self {
        let mut prg_ram = MemoryBlock::new(cartridge.prg_ram_bytes / 1024);
        if let Some(wram) = cartridge.wram.take() {
            prg_ram.restore_wram(wram);
        }

        let mut fpga_ram = FixedMemoryBlock::new();
        for (addr, &value) in BOOTROM_FPGA.iter().enumerate() {
            fpga_ram.write(addr, value);
        }

        let chr_ram = if cartridge.chr_ram_bytes >= 1024 {
            Some(MemoryBlock::new(cartridge.chr_ram_bytes / 1024))
        } else {
            None
        };
        let nt_ram = FixedMemoryBlock::new();

        let master_volume = (i16::MAX as f32 / 64.0) as i16;

        Self {
            cartridge,
            debug,
            prg_ram,
            chr_ram,
            fpga_ram,
            nt_ram,
            prg_mode: 0,
            prg_lo_regs: [0; 8],
            prg_hi_regs: [0; 8],
            prg_ram_lo_regs: [0; 2],
            prg_ram_hi_regs: [0; 2],
            fpga_ram_reg: 0,
            chr_mode: 0,
            bg_ext_hi: 0,
            nt_bank_regs: [0, 0, 1, 1, 0],
            nt_mode_regs: [0, 0, 0, 0, 0x80],
            fill_tile: 0,
            fill_attr: 0,
            chr_lo_regs: [0; 16],
            chr_hi_regs: [0; 16],
            spr_ext_lo: SpriteExtRegs([0; 64]),
            spr_ext_hi: 0,
            ppu_state: PpuState::new(),
            ppu_irq_enabled: false,
            oam_state: ShadowOam::new(),
            cpu_irq_latch: 0,
            cpu_irq_counter: 0,
            cpu_irq_pending: false,
            cpu_irq_enable: false,
            cpu_irq_ack_enable: false,
            cpu_irq_4011_ack: false,
            fpga_reader_addr: 0,
            fpga_reader_inc: 1,
            pulse_a: Pulse::new(),
            pulse_b: Pulse::new(),
            sawtooth: Sawtooth::new(),
            audio_enable: true,
            audio_4011_out: false,
            master_volume,
            redir_nmi: false,
            redir_nmi_lo: 0,
            redir_nmi_hi: 0,
            redir_irq: false,
            redir_irq_lo: 0,
            redir_irq_hi: 0,
            wifi_enable: false,
            wifi_irq_enable: false,
            wifi_tx_addr: 0,
            wifi_rx_addr: 0,
            wifi_data_pending: false,
            window_tile_start: 0,
            window_tile_end: 0,
            window_line_start: 0,
            window_line_end: 0,
            window_tile_scroll: 0,
            window_line_scroll: 0,
            warn_oam: false,
        }
    }

    fn peek_cpu(&self, addr: u16) -> u8 {
        match addr {
            0x4011 if self.audio_4011_out => {
                (self.pulse_a.sample() + self.pulse_b.sample() + self.sawtooth.sample()) << 1
            }
            0x4100 => self.prg_mode,
            0x4120 => self.chr_mode,
            0x412a..=0x412d => self.nt_mode_regs[(addr - 0x412a) as usize],
            0x412f => self.nt_mode_regs[4],
            0x4150 => self.ppu_state.scanline,
            0x4151 => {
                let mut val = 0;
                if self.ppu_state.irq_pending {
                    val |= 1;
                }
                if self.ppu_state.in_frame {
                    val |= 0x40;
                }
                if self.ppu_state.hblank() {
                    val |= 0x80;
                }

                val
            }
            0x4154 => self.ppu_state.irq_jitter,
            0x415f => self.fpga_ram.read(self.fpga_reader_addr),
            0x4160 => 0x20,
            0x4161 => {
                let mut val = 0;
                if self.cpu_irq_pending {
                    val |= 0x40;
                }
                if self.ppu_state.irq_pending {
                    val |= 0x80;
                }

                val
            }
            0x4190 => {
                let mut val = 0;
                if self.wifi_enable {
                    val |= 1;
                }
                if self.wifi_irq_enable {
                    val |= 2;
                }

                val
            }
            0x4191 => 0,
            0x4192 => {
                let mut val = 0;
                if !self.wifi_data_pending {
                    val |= 0x80;
                }

                val
            }
            0xfffa if self.redir_nmi => self.redir_nmi_lo,
            0xfffb if self.redir_nmi => self.redir_nmi_hi,
            0xfffe if self.redir_irq => self.redir_irq_lo,
            0xffff if self.redir_irq => self.redir_irq_hi,
            0x4800.. => self.read_prg(addr),
            _ => 0,
        }
    }

    fn read_cpu(&mut self, addr: u16) -> u8 {
        match addr {
            0x4011 => {
                if self.cpu_irq_4011_ack {
                    self.cpu_irq_pending = false;
                    self.cpu_irq_enable = self.cpu_irq_ack_enable;
                }
            }
            0x4151 => {
                let mut val = 0;
                if self.ppu_state.irq_pending {
                    val |= 1;
                }
                if self.ppu_state.in_frame {
                    val |= 0x40;
                }
                if self.ppu_state.hblank() {
                    val |= 0x80;
                }

                self.ppu_state.irq_pending = false;
                return val;
            }
            0x415f => {
                let val = self.fpga_ram.read(self.fpga_reader_addr);
                self.fpga_reader_addr += self.fpga_reader_inc as u16;
                self.fpga_reader_addr &= 0x1fff;
                return val;
            }
            0x4280..=0x4286 => {
                if !self.warn_oam {
                    tracing::error!("rainbow oam routine unsupported: {:04x}", addr);
                    self.warn_oam = true;
                }
                return 0x60; // RTS
            }
            0xfffa | 0xfffb => self.ppu_state.leave_frame(),
            _ => (),
        }
        self.peek_cpu(addr)
    }

    fn write_cpu(&mut self, addr: u16, value: u8) {
        match addr {
            0x2000 => self.oam_state.ppu_ctrl(value),
            0x2003 => self.oam_state.oam_addr(value),
            0x2004 => self.oam_state.oam_data(value),
            0x4100 => self.prg_mode = value,
            0x4108..=0x410f => self.prg_hi_regs[(addr & 7) as usize] = value,
            0x4118..=0x411f => self.prg_lo_regs[(addr & 7) as usize] = value,
            0x4106..=0x4107 => self.prg_ram_hi_regs[(addr & 1) as usize] = value,
            0x4116..=0x4117 => self.prg_ram_lo_regs[(addr & 1) as usize] = value,
            0x4115 => self.fpga_ram_reg = value,
            0x4120 => self.chr_mode = value,
            0x4121 => self.bg_ext_hi = value,
            0x4126..=0x4129 => self.nt_bank_regs[(addr - 0x4126) as usize] = value,
            0x412a..=0x412d => self.nt_mode_regs[(addr - 0x412a) as usize] = value,
            0x412e => self.nt_bank_regs[4] = value,
            0x412f => self.nt_mode_regs[4] = (value & 0x3f) | 0x80,
            0x4124 => self.fill_tile = value,
            0x4125 => self.fill_attr = (value & 3) * 0b0101_0101,
            0x4130..=0x413f => self.chr_hi_regs[(addr & 0xf) as usize] = value,
            0x4140..=0x414f => self.chr_lo_regs[(addr & 0xf) as usize] = value,
            0x4150 => self.ppu_state.scanline_compare = value,
            0x4151 => self.ppu_irq_enabled = true,
            0x4152 => {
                self.ppu_irq_enabled = false;
                self.ppu_state.irq_pending = false;
            }
            0x4153 => self.ppu_state.irq_offset = value.max(1).min(170),
            0x4158 => self.cpu_irq_latch = (self.cpu_irq_latch & 0x00ff) | ((value as u16) << 8),
            0x4159 => self.cpu_irq_latch = (self.cpu_irq_latch & 0xff00) | (value as u16),
            0x415a => {
                self.cpu_irq_enable = value & 1 != 0;
                self.cpu_irq_ack_enable = value & 2 != 0;
                self.cpu_irq_4011_ack = value & 4 != 0;

                if self.cpu_irq_enable {
                    self.cpu_irq_counter = self.cpu_irq_latch;
                }
            }
            0x415b => {
                self.cpu_irq_pending = false;
                self.cpu_irq_enable = self.cpu_irq_ack_enable;
            }
            0x415c => {
                self.fpga_reader_addr =
                    (self.fpga_reader_addr & 0x00ff) | ((value as u16 & 0x1f) << 8)
            }
            0x415d => self.fpga_reader_addr = (self.fpga_reader_addr & 0xff00) | (value as u16),
            0x415e => self.fpga_reader_inc = value,
            0x415f => {
                self.fpga_ram.write(self.fpga_reader_addr, value);
                self.fpga_reader_addr += self.fpga_reader_inc as u16;
                self.fpga_reader_addr &= 0x1fff;
            }
            0x416b => {
                self.redir_nmi = value & 1 != 0;
                self.redir_irq = value & 2 != 0;
            }
            0x416c => self.redir_nmi_hi = value,
            0x416d => self.redir_nmi_lo = value,
            0x416e => self.redir_irq_hi = value,
            0x416f => self.redir_irq_lo = value,
            0x4170 => self.window_tile_start = value & 0x1f,
            0x4171 => self.window_tile_end = value & 0x1f,
            0x4172 => self.window_line_start = value,
            0x4173 => self.window_line_end = value,
            0x4174 => self.window_tile_scroll = value & 0x1f,
            0x4175 => self.window_line_scroll = value,
            0x4190 => {
                self.wifi_enable = value & 1 != 0;
                self.wifi_irq_enable = value & 2 != 0;
            }
            0x4191 => (),
            0x4192 => self.wifi_data_pending = true,
            0x4193 => self.wifi_rx_addr = value & 0x7,
            0x4194 => self.wifi_tx_addr = value & 0x7,
            0x41a0 => self.pulse_a.volume(value),
            0x41a1 => self.pulse_a.freq_low(value),
            0x41a2 => self.pulse_a.freq_high(value),
            0x41a3 => self.pulse_b.volume(value),
            0x41a4 => self.pulse_b.freq_low(value),
            0x41a5 => self.pulse_b.freq_high(value),
            0x41a6 => self.sawtooth.accumulator_rate(value),
            0x41a7 => self.sawtooth.freq_low(value),
            0x41a8 => self.sawtooth.freq_high(value),
            0x41a9 => {
                self.audio_enable = value & 3 != 0;
                self.audio_4011_out = value & 4 != 0;
            }
            0x41aa => {
                let vol = (value & 0xf) as f32 / 15.0;
                self.master_volume = (i16::MAX as f32 * vol / 64.0) as i16;
            }
            0x4200..=0x423f => self.spr_ext_lo[(addr & 0x3f) as usize] = value,
            0x4240 => self.spr_ext_hi = value,
            0x4800.. => self.write_prg(addr, value),
            _ => tracing::debug!("unsupported rainbow write reg: {addr:04x}:{value:02x}"),
        }
    }

    fn read_ppu(&self, addr: u16) -> u8 {
        let (addr, nt_idx) = if let Some(win_addr) = self.window_address(addr) {
            (win_addr, 4)
        } else {
            (addr, ((addr >> 10) & 0x3) as usize)
        };

        let oam = (self.chr_mode & 0x20 != 0).then_some(&self.oam_state);
        let ppu_read = self.ppu_state.read(oam);

        if addr & 0x2000 != 0 {
            let mode = self.nt_mode_regs[nt_idx];
            let bank = self.nt_bank_regs[nt_idx] as usize;

            let fill = mode & 0x20 != 0;
            let ext_attr = mode & 0x1 != 0;
            let chip = mode >> 6 & 3;

            match ppu_read {
                Some(PpuRead::Attribute) if fill => return self.fill_attr,
                Some(PpuRead::Nametable) if fill => return self.fill_tile,
                Some(PpuRead::ExtAttribute(attr)) if ext_attr => return attr,
                _ => (),
            }

            match chip {
                0 => self.nt_ram.read_mapped(bank & 1, 1024, addr),
                1 => {
                    if let Some(chr_ram) = self.chr_ram.as_ref() {
                        chr_ram.read_mapped(bank, 1024, addr)
                    } else {
                        0
                    }
                }
                2 => self.fpga_ram.read_mapped(bank & 3, 1024, addr),
                3 => self.cartridge.chr_rom.read_mapped(bank, 1024, addr),
                _ => unreachable!(),
            }
        } else {
            match ppu_read {
                Some(PpuRead::ExtBg(bank)) => {
                    let bank = bank as usize | (self.bg_ext_hi as usize & 0x1f) << 6;
                    self.read_bank_chr(bank, addr, 4096)
                }
                Some(PpuRead::ExtSprite(sprite)) => {
                    let bank = self.spr_ext_lo[sprite as usize] as usize
                        | (self.spr_ext_hi as usize & 0x07) << 8;
                    self.read_bank_chr(bank, addr, 4096)
                }
                _ => self.read_chr(addr),
            }
        }
    }

    fn write_ppu(&mut self, addr: u16, value: u8) {
        if addr & 0x2000 != 0 {
            let nt_idx = ((addr >> 10) & 0x3) as usize;
            let mode = self.nt_mode_regs[nt_idx];
            let bank = self.nt_bank_regs[nt_idx] as usize;
            let chip = mode >> 6 & 3;

            match chip {
                0 => self.nt_ram.write_mapped(bank & 1, 1024, addr, value),
                1 => {
                    if let Some(chr_ram) = self.chr_ram.as_mut() {
                        chr_ram.write_mapped(bank, 1024, addr, value);
                    }
                }
                2 => self.fpga_ram.write_mapped(bank & 3, 1024, addr, value),
                3 => (), // chr-rom,
                _ => unreachable!(),
            }
        } else {
            self.write_chr(addr, value);
        }
    }

    fn read_prg(&self, addr: u16) -> u8 {
        let (bank, size, mem_source) = self.map_prg(addr);
        match mem_source {
            MemSource::Rom => self.cartridge.prg_rom.read_mapped(bank, size, addr),
            MemSource::Ram => self.prg_ram.read_mapped(bank, size, addr),
            MemSource::Fpga => self.fpga_ram.read_mapped(bank, size, addr),
        }
    }

    fn write_prg(&mut self, addr: u16, value: u8) {
        let (bank, size, mem_source) = self.map_prg(addr);
        match mem_source {
            MemSource::Rom => self.cartridge.prg_rom.write_mapped(bank, size, addr, value),
            MemSource::Ram => self.prg_ram.write_mapped(bank, size, addr, value),
            MemSource::Fpga => self.fpga_ram.write_mapped(bank, size, addr, value),
        }
    }

    fn map_prg(&self, addr: u16) -> (usize, usize, MemSource) {
        if addr < 0x6000 {
            let (bank, size) = match addr {
                0x4800..0x5000 => (3, 2 * 1024),
                0x5000..0x6000 => ((self.fpga_ram_reg & 1) as usize, 4 * 1024),
                _ => unreachable!(),
            };
            return (bank, size, MemSource::Fpga);
        }

        let prg_rom_mode = self.prg_mode & 0x7;
        let prg_ram_mode = self.prg_mode >> 7;
        let ram_bank = addr < 0x8000;
        let (bank_idx, size_kb) = if ram_bank {
            match (addr, prg_ram_mode) {
                (0x6000..0x8000, 0) => (0, 8),
                (0x6000..0x7000, 1) => (0, 4),
                (0x7000..0x8000, 1) => (1, 4),
                _ => unreachable!(),
            }
        } else {
            let addr = addr >> 12 & 7;
            match prg_rom_mode {
                0 => (0, 32),
                1 => (addr & 0xfffc, 16),
                2 => match addr >> 1 {
                    2 => (4, 8),
                    3 => (6, 8),
                    _ => (0, 16),
                },
                3 => (addr & 0xfffe, 8),
                _ => (addr, 4),
            }
        };
        let bank_idx = bank_idx as usize;
        let size = size_kb * 1024;

        let bank_reg = if ram_bank {
            (self.prg_ram_hi_regs[bank_idx] as usize) << 8 | self.prg_ram_lo_regs[bank_idx] as usize
        } else {
            (self.prg_hi_regs[bank_idx] as usize) << 8 | self.prg_lo_regs[bank_idx] as usize
        };

        let mem_source = match bank_reg >> 14 & 3 {
            0 | 1 => MemSource::Rom,
            3 if ram_bank => MemSource::Fpga,
            _ => MemSource::Ram,
        };

        let bank = bank_reg & 0x7fff;

        (bank, size, mem_source)
    }

    fn read_chr(&self, addr: u16) -> u8 {
        if self.chr_mode & 0x80 != 0 {
            return self.fpga_ram.read(addr);
        }

        let ram = self.chr_mode & 0x40 != 0;

        let (bank, size) = self.map_chr(addr);

        if ram {
            if let Some(chr_ram) = self.chr_ram.as_ref() {
                chr_ram.read_mapped(bank, size, addr)
            } else {
                0
            }
        } else {
            self.cartridge.chr_rom.read_mapped(bank, size, addr)
        }
    }

    fn read_bank_chr(&self, bank: usize, addr: u16, size: usize) -> u8 {
        if self.chr_mode & 0x80 != 0 {
            return self.fpga_ram.read(addr);
        }

        let ram = self.chr_mode & 0x40 != 0;

        if ram {
            if let Some(chr_ram) = self.chr_ram.as_ref() {
                chr_ram.read_mapped(bank, size, addr)
            } else {
                0
            }
        } else {
            self.cartridge.chr_rom.read_mapped(bank, size, addr)
        }
    }

    fn write_chr(&mut self, addr: u16, value: u8) {
        if self.chr_mode & 0x80 != 0 {
            return self.fpga_ram.write(addr, value);
        }

        let ram = self.chr_mode & 0x40 != 0;
        if !ram {
            return;
        }

        let (bank, size) = self.map_chr(addr);

        if let Some(chr_ram) = self.chr_ram.as_mut() {
            chr_ram.write_mapped(bank, size, addr, value);
        }
    }

    fn map_chr(&self, addr: u16) -> (usize, usize) {
        let size: usize = match self.chr_mode & 7 {
            0 => 8 * 1024,
            1 => 4 * 1024,
            2 => 2 * 1024,
            3 => 1024,
            _ => 512,
        };

        let bank_idx = (addr >> size.trailing_zeros()) as usize;
        let hi = self.chr_hi_regs[bank_idx] as usize;
        let lo = self.chr_lo_regs[bank_idx] as usize;
        (hi << 8 | lo, size)
    }

    fn is_in_window(&self, tile: u8, scanline: u8) -> bool {
        if self.window_tile_start <= self.window_tile_end {
            if tile < self.window_tile_start || tile > self.window_tile_end {
                return false;
            }
        } else {
            if tile < self.window_tile_start && tile > self.window_tile_end {
                return false;
            }
        }

        if self.window_line_start <= self.window_line_end {
            if scanline < self.window_line_start || scanline > self.window_line_end {
                return false;
            }
        } else {
            if scanline < self.window_line_start && scanline > self.window_line_end {
                return false;
            }
        }

        true
    }

    fn window_address(&self, addr: u16) -> Option<u16> {
        if self.chr_mode & 0x10 == 0 {
            return None;
        }

        let tile = self.ppu_state.tile_number()?;
        let scanline = self.ppu_state.render_line()?;

        if !self.is_in_window(tile, scanline) {
            return None;
        }

        let x = self.window_tile_scroll as u16 + tile as u16;
        let y = self.window_line_scroll as u16 + scanline as u16;
        let mut coarse_y = y >> 3;
        if coarse_y >= 30 {
            coarse_y -= 30;
        }

        let nt_addr = ((coarse_y) << 5) | (x & 0x1f);

        match self.ppu_state.read(None)? {
            PpuRead::Attribute => Some(
                0x23c0 | (nt_addr & 0x0c00) | ((nt_addr >> 4) & 0x38) | ((nt_addr >> 2) & 0x07),
            ),
            PpuRead::Nametable => Some(0x2000 | (nt_addr & 0xfff)),
            PpuRead::Bg => Some((addr & 0xfff8) | (y & 7)),
            _ => None,
        }
    }
}

impl Mapper for Rainbow {
    fn register(&self, cpu: &mut AddressBus) {
        cpu.register_read(DeviceKind::Mapper, AndAndMask(0x8000, 0xffff));
        cpu.register_write(DeviceKind::Mapper, AndAndMask(0x8000, 0xffff));
        cpu.register_read(DeviceKind::Mapper, AndEqualsAndMask(0xe000, 0x6000, 0x7fff));
        cpu.register_write(DeviceKind::Mapper, AndEqualsAndMask(0xe000, 0x6000, 0x7fff));

        cpu.register_read(DeviceKind::Mapper, AndEqualsAndMask(0xf000, 0x5000, 0xffff));
        cpu.register_write(DeviceKind::Mapper, AndEqualsAndMask(0xf000, 0x5000, 0xffff));

        cpu.register_read(DeviceKind::Mapper, AndEqualsAndMask(0xff00, 0x4100, 0xffff));
        cpu.register_write(DeviceKind::Mapper, AndEqualsAndMask(0xff00, 0x4100, 0xffff));

        cpu.register_read(DeviceKind::Mapper, AndEqualsAndMask(0xff00, 0x4200, 0xffff));
        cpu.register_write(DeviceKind::Mapper, AndEqualsAndMask(0xff00, 0x4200, 0xffff));

        cpu.register_read(DeviceKind::Mapper, AndEqualsAndMask(0xf800, 0x4800, 0xffff));
        cpu.register_write(DeviceKind::Mapper, AndEqualsAndMask(0xf800, 0x4800, 0xffff));

        cpu.register_write(DeviceKind::Mapper, Address(0x2000));
        cpu.register_write(DeviceKind::Mapper, Address(0x2003));
        cpu.register_write(DeviceKind::Mapper, Address(0x2004));

        cpu.register_read(DeviceKind::Mapper, Address(0x4011));
    }

    fn peek(&self, bus: BusKind, addr: u16) -> u8 {
        match bus {
            BusKind::Cpu => self.peek_cpu(addr),
            BusKind::Ppu => self.read_ppu(addr),
        }
    }

    fn read(&mut self, bus: BusKind, addr: u16) -> u8 {
        match bus {
            BusKind::Cpu => self.read_cpu(addr),
            BusKind::Ppu => self.read_ppu(addr),
        }
    }

    fn write(&mut self, bus: BusKind, addr: u16, value: u8) {
        match bus {
            BusKind::Cpu => self.write_cpu(addr, value),
            BusKind::Ppu => self.write_ppu(addr, value),
        }
    }

    fn peek_ppu_fetch(&self, _address: u16, _kind: PpuFetchKind) -> Nametable {
        // Storing CIRAM inside mapper to give a chance to apply windowing and ext-attr
        Nametable::External
    }

    fn ppu_fetch(&mut self, address: u16, kind: PpuFetchKind) -> Nametable {
        if kind != PpuFetchKind::Idle {
            let nt_mode = if (address & 0x2000) != 0 {
                let nt_idx = ((address >> 10) & 0x3) as usize;
                Some(self.nt_mode_regs[nt_idx])
            } else {
                None
            };
            let was_irq = self.ppu_state.irq_pending;
            self.ppu_state
                .fetch(address, nt_mode, &self.fpga_ram, &mut self.oam_state);
            if self.ppu_irq_enabled && !was_irq && self.ppu_state.irq_pending {
                self.debug.event(crate::DebugEvent::MapperIrq);
            }
        }

        self.peek_ppu_fetch(address, kind)
    }

    fn tick(&mut self) {
        if self.cpu_irq_enable {
            self.cpu_irq_counter = self.cpu_irq_counter.saturating_sub(1);
            if self.cpu_irq_counter == 0 {
                self.cpu_irq_counter = self.cpu_irq_latch;
                self.cpu_irq_pending = true;
                self.debug.event(crate::DebugEvent::MapperIrq);
            }
        }
        self.ppu_state.tick();
        self.pulse_a.tick(FreqMode::X1);
        self.pulse_b.tick(FreqMode::X1);
        self.sawtooth.tick(FreqMode::X1);
    }

    fn get_irq(&self) -> bool {
        (self.ppu_irq_enabled && self.ppu_state.irq_pending)
            || (self.cpu_irq_enable && self.cpu_irq_pending)
    }

    fn get_sample(&self) -> Option<i16> {
        if self.audio_enable {
            let val = (self.pulse_a.sample() as i16
                + self.pulse_b.sample() as i16
                + self.sawtooth.sample() as i16)
                * self.master_volume;

            Some(val)
        } else {
            Some(0)
        }
    }

    fn save_wram(&self) -> Option<super::SaveWram> {
        if self.cartridge.battery {
            self.prg_ram.save_wram()
        } else {
            None
        }
    }
}

#[cfg_attr(feature = "save-states", derive(Serialize, Deserialize))]
#[derive(Debug, Clone)]
struct PpuState {
    last_address: Option<u16>,
    match_count: u8,
    in_frame: bool,
    line_fetches: u8,
    scanline: u8,
    scanline_compare: u8,
    irq_pending: bool,
    reading: bool,
    idle_ticks: u8,
    irq_offset: u8,
    irq_jitter: u8,
    ext_bg: Option<(bool, bool, u8)>,
}

impl PpuState {
    fn new() -> Self {
        Self {
            last_address: None,
            match_count: 0,
            in_frame: false,
            line_fetches: 0,
            scanline: 0,
            scanline_compare: 0,
            irq_pending: false,
            reading: false,
            idle_ticks: 0,
            irq_offset: 135,
            irq_jitter: 0,
            ext_bg: None,
        }
    }

    fn fetch(
        &mut self,
        addr: u16,
        nt_mode: Option<u8>,
        fpga: &FixedMemoryBlock<8>,
        oam: &mut ShadowOam,
    ) {
        self.line_fetches = self.line_fetches.saturating_add(1);

        if self.line_fetches == self.irq_offset
            && self.scanline == self.scanline_compare
            && self.scanline != 0
        {
            self.irq_pending = true;
            self.irq_jitter = 0;
        }

        if addr >= 0x2000 && addr <= 0x2fff && Some(addr) == self.last_address {
            self.match_count += 1;
            if self.match_count == 2 {
                if self.in_frame {
                    self.scanline += 1;
                } else {
                    self.in_frame = true;
                    self.scanline = 0;
                }
                oam.eval(self.scanline);
                self.line_fetches = 0;
            }
        } else {
            self.match_count = 0;
        }

        self.last_address = Some(addr);
        self.reading = true;

        if self.in_frame && self.line_fetches >= 128 && self.line_fetches < 160 {
            oam.oam_addr(0);
        }

        if let Some(nt_mode) = nt_mode {
            if self.in_frame && nt_mode & 0x3 != 0 {
                if self.line_fetches & 3 == 0 {
                    let fpga_bank = (nt_mode >> 2) & 3;
                    let fpga_addr = (fpga_bank as u16 * 0x400) | (addr & 0x3ff);
                    let value = fpga.read(fpga_addr);
                    self.ext_bg = Some((nt_mode & 1 != 0, nt_mode & 2 != 0, value));
                }
            } else {
                self.ext_bg = None;
            }
        }
    }

    fn read(&self, oam: Option<&ShadowOam>) -> Option<PpuRead> {
        if !self.in_frame {
            return None;
        }

        let read = match self.line_fetches {
            fetches if fetches < 128 => match (fetches & 3, self.ext_bg) {
                (0, _) => PpuRead::Nametable,
                (1, Some((true, _, b))) => PpuRead::ExtAttribute((b >> 6) * 0b0101_0101),
                (1, _) => PpuRead::Attribute,
                (2 | 3, Some((_, true, b))) => PpuRead::ExtBg(b & 0x3f),
                (2 | 3, _) => PpuRead::Bg,
                _ => unreachable!(),
            },
            fetches if fetches >= 128 && fetches < 160 => match (fetches & 3, oam) {
                (0 | 1, _) => PpuRead::Nametable,
                (2 | 3, Some(oam)) => {
                    let idx = (fetches as usize - 128) / 4;
                    let tile = oam.line_oam[idx];
                    PpuRead::ExtSprite(tile)
                }
                (2 | 3, _) => PpuRead::Sprite,
                _ => unreachable!(),
            },
            fetches if fetches >= 160 && fetches < 168 => match (fetches & 3, self.ext_bg) {
                (0, _) => PpuRead::Nametable,
                (1, Some((true, _, b))) => PpuRead::ExtAttribute((b >> 6) * 0b0101_0101),
                (1, _) => PpuRead::Attribute,
                (2 | 3, Some((_, true, b))) => PpuRead::ExtBg(b & 0x3f),
                (2 | 3, _) => PpuRead::Bg,
                _ => unreachable!(),
            },
            fetches if fetches >= 168 && fetches < 170 => PpuRead::Nametable,
            _ => return None,
        };

        Some(read)
    }

    fn tile_number(&self) -> Option<u8> {
        if !self.in_frame {
            return None;
        }

        let fetches = self.line_fetches;
        if fetches < 128 {
            Some((fetches / 4) + 2)
        } else if fetches < 160 {
            None
        } else if fetches < 168 {
            Some((fetches - 160) / 4)
        } else {
            None
        }
    }

    fn render_line(&self) -> Option<u8> {
        if !self.in_frame {
            return None;
        }

        if self.line_fetches >= 160 {
            Some(self.scanline.wrapping_add(1))
        } else {
            Some(self.scanline)
        }
    }

    fn tick(&mut self) {
        self.irq_jitter = self.irq_jitter.saturating_add(1);
        if self.reading {
            self.idle_ticks = 0;
        } else {
            self.idle_ticks = self.idle_ticks.saturating_add(1);
            if self.idle_ticks == 3 {
                self.leave_frame();
            }
        }
        self.reading = false;
    }

    fn hblank(&self) -> bool {
        self.in_frame && self.line_fetches >= 128
    }

    fn leave_frame(&mut self) {
        self.in_frame = false;
        self.irq_pending = false;
        self.scanline = 0;
        self.last_address = None;
        self.ext_bg = None;
    }
}

#[cfg_attr(feature = "save-states", derive(Serialize, Deserialize))]
#[derive(Debug, Clone)]
struct ShadowOam {
    ppu_ctrl: u8,
    oam_addr: u8,
    #[cfg_attr(feature = "save-states", serde(with = "serde_arrays"))]
    oam: [u8; 256],
    line_oam: [u8; 8],
}

impl ShadowOam {
    fn new() -> Self {
        Self {
            ppu_ctrl: 0,
            oam_addr: 0,
            oam: [0; 256],
            line_oam: [0; 8],
        }
    }

    fn ppu_ctrl(&mut self, value: u8) {
        self.ppu_ctrl = value;
    }

    fn oam_addr(&mut self, value: u8) {
        self.oam_addr = value;
    }

    fn oam_data(&mut self, value: u8) {
        self.oam[self.oam_addr as usize] = value;
        self.oam_addr = self.oam_addr.wrapping_add(1);
    }

    fn tall_sprite(&self) -> bool {
        self.ppu_ctrl & 0x20 != 0
    }

    fn eval(&mut self, scanline: u8) {
        let height = if self.tall_sprite() { 16 } else { 8 };
        let end = scanline + height;

        let mut sprites_on_line = 0;

        for (idx, s) in self.oam.chunks(4).enumerate() {
            if s[0] >= scanline && s[0] < end {
                self.line_oam[sprites_on_line] = idx as u8;
                sprites_on_line += 1;
                if sprites_on_line == 8 {
                    break;
                }
            }
        }
    }
}

// Sourced from Rustico - apparently originally provided by Broke Studio, used to initialize FPGA RAM
// and is required to properly run the test rom
const BOOTROM_FPGA: [u8; 4096] = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x38, 0x7C, 0x38, 0xFE, 0xFE, 0xD6, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x03, 0x0F, 0x1C, 0x30, 0x30, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC0, 0xF0, 0x3A, 0x1E, 0x0E, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1C, 0x1C, 0x1C, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x44, 0xC6, 0xC6, 0xFE, 0x7C, 0x38, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0D, 0x0D, 0x00, 0x0F, 0xDF, 0xD8, 0x1B, 0xDB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xB0, 0xB0, 0x00, 0xF0, 0xFB, 0x1B, 0xD8, 0xDB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0x1F, 0x38, 0x75, 0x65, 0x65, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFE, 0xFE, 0x06, 0x56, 0x56, 0x56, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7F, 0x63, 0x7F, 0x63, 0x63, 0x67, 0xE6, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7F, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7E, 0xC3, 0x78, 0xCC, 0xCC, 0x78, 0x8C, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x60, 0x30, 0x30, 0x1C, 0x0F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0C, 0x0C, 0x38, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x1C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x38, 0x38, 0x38, 0x38, 0x38, 0x28, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xDB, 0x1B, 0xD8, 0xDF, 0x0F, 0x00, 0x0D, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xDB, 0xD8, 0x1B, 0xFB, 0xF0, 0x00, 0xB0, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x60, 0x60, 0x60, 0x60, 0x7F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x06, 0x06, 0x06, 0x06, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0xCC, 0xDC, 0xFC, 0xEC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0xF0, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0xCC, 0x0C, 0x38, 0x60, 0xCC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0xCC, 0x0C, 0x38, 0x0C, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFC, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x38, 0x60, 0xC0, 0xF8, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFC, 0xCC, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0xCC, 0xCC, 0x78, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0xCC, 0xCC, 0x7C, 0x0C, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x30, 0x30, 0x00, 0x70, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x30, 0x60, 0xC0, 0x60, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFC, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0xCC, 0x0C, 0x18, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x78, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFC, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0xCC, 0xCC, 0xCC, 0xDC, 0x78, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFC, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0xCC, 0xE0, 0x38, 0x1C, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFC, 0xB4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFE, 0xCC, 0x98, 0x30, 0x62, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0x60, 0x7C, 0x66, 0x66, 0x66, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x38, 0x6C, 0x60, 0xF0, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x00, 0x78, 0x18, 0x18, 0x18, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xD8, 0x6C, 0x6C, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x30, 0x7C, 0x30, 0x30, 0x34, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1C, 0x30, 0x30, 0xE0, 0x30, 0x30, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x03, 0x0F, 0x1E, 0x3E, 0x3F, 0x7E, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xC0, 0xF0, 0x78, 0x7C, 0xFC, 0x7E, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x07, 0x1F, 0x3F, 0x78, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xE0, 0xF8, 0xFC, 0x1E, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x70, 0xF8, 0x7C, 0x3F, 0x1F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x1C, 0x3E, 0x7C, 0xF8, 0xF0, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x05, 0x0E, 0x1C, 0x38, 0x70, 0xE0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x51, 0x71, 0x71, 0x71, 0x7F, 0x71, 0x7F, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFA, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3F, 0x07, 0x0F, 0x1D, 0x39, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x23, 0x27, 0x2E, 0x3C, 0x38, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0x47, 0x47, 0xE7, 0x00, 0x00, 0xE0, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x02, 0x02, 0x04, 0x04, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x8C, 0x02, 0x32, 0x81, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7E, 0x7E, 0x3E, 0x3E, 0x1F, 0x0F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7E, 0x7E, 0x7C, 0x7C, 0xF8, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x83, 0x87, 0x0C, 0x08, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC1, 0xE1, 0x30, 0x10, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0x1F, 0x3F, 0x7C, 0xF8, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0xF0, 0xF8, 0x7C, 0x3E, 0x1C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x27, 0x53, 0xA9, 0x54, 0x2A, 0x15, 0x0A, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7F, 0x71, 0x7F, 0x31, 0x3F, 0x31, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFE, 0xFE, 0xFE, 0xFC, 0xFC, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x44, 0xEE, 0x7C, 0x38, 0x7C, 0xEE, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x08, 0x14, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x47, 0xE7, 0x00, 0x00, 0xE0, 0x47, 0x27, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x05, 0x0E, 0x1C, 0x38, 0x70, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x8C, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3C, 0x7C, 0xFF, 0xFF, 0x80, 0x80, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xF8, 0xF8, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3C, 0xFC, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x40, 0x82, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
    0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x30, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0x60, 0x70, 0x78, 0x3C, 0x04, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3E, 0x3E, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x01, 0x03, 0x02, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0x80, 0xC0, 0x40, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3F, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFC, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0x7E, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3F, 0x7C, 0x79, 0x7F, 0x7F, 0x7E, 0x7E, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFC, 0x3E, 0x9E, 0x9E, 0x3E, 0x7E, 0x7E, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x04, 0x3F, 0x7F, 0x00, 0x35, 0x35, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF0, 0x10, 0xFE, 0xFF, 0x00, 0x56, 0x56, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFE, 0xFE, 0xFE, 0xFC, 0xFC, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x3F, 0x30, 0x3F, 0x30, 0x3F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0C, 0xFC, 0x0C, 0xFC, 0x0C, 0xFC, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x30, 0x3E, 0x3E, 0x3E, 0x3F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0C, 0x0C, 0x7C, 0x7C, 0x7C, 0xFC, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0E, 0x0E, 0x1E, 0x1F, 0x3E, 0x3E, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x70, 0x78, 0xF8, 0x7C, 0x7C, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7E, 0x7E, 0x7F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7E, 0x7E, 0xFE, 0xFC, 0xF8, 0x38, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7E, 0x7E, 0x7F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7E, 0x7E, 0xFE, 0xFC, 0xF8, 0x38, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x3F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0C, 0x1E, 0x3E, 0x38, 0x70, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x07, 0x08, 0x10, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xE0, 0xF8, 0x3C, 0x1E, 0x0E, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0xFE, 0xFC, 0xF8, 0xF1, 0xE3, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x1E, 0x33, 0x73, 0xFE, 0xFC, 0xF8, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x07, 0x2E, 0xFC, 0xF8, 0xFC, 0x78, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x1C, 0x0F, 0x0F, 0x1C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x07, 0x0F, 0x1C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xE0, 0xF0, 0x38, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3F, 0x3F, 0x3F, 0x3F, 0x3E, 0x3E, 0x3F, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0xE0, 0xF0, 0xF8, 0x7C, 0x7C, 0xFC, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x20, 0x20, 0x10, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE7, 0xE1, 0xC5, 0xC8, 0xC0, 0xE3, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0xC0, 0x80, 0x10, 0x30, 0xF0, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1C, 0x3E, 0x1F, 0x1F, 0x3F, 0x72, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x38, 0xF0, 0xF0, 0x38, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x1C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x18, 0x38, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0xFC, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x18, 0x17, 0x16, 0x36, 0x36, 0x30, 0x1F, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x79, 0xB6, 0x32, 0xBA, 0x32, 0x78, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x82, 0x84, 0x84, 0x88, 0x88, 0x80, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x11, 0x9C, 0x1E, 0x0F, 0x1F, 0x5F, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC0, 0xE4, 0xF0, 0xFC, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x03, 0x03, 0x07, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0x80, 0xC0, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0x18, 0x30, 0x67, 0xCC, 0x98, 0x91, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0x30, 0x18, 0xCC, 0x66, 0x32, 0x12, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x1F, 0x3E, 0x77, 0x6F, 0xFE, 0xDC, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0xF8, 0x7C, 0xBE, 0xBE, 0x17, 0x07, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x0F, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x70, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x0E, 0x0F, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0E, 0x67, 0xF3, 0x50, 0x02, 0x7C, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE7, 0x06, 0xF8, 0x00, 0x04, 0x03, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x2C, 0x2C, 0x38, 0x00, 0x00, 0xE0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x10, 0x00, 0x7F, 0x9F, 0x97, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x08, 0x00, 0xFE, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x02, 0x02, 0x04, 0x04, 0x04, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3F, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F, 0x78, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF8, 0xF0, 0xF0, 0xF0, 0xF8, 0xF8, 0x3C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x91, 0x00, 0x03, 0x07, 0x07, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x12, 0x00, 0x80, 0xC0, 0xC0, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC8, 0xC4, 0xE6, 0x67, 0x73, 0x3E, 0x1F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1F, 0x1F, 0x07, 0x86, 0x8E, 0x3C, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1E, 0x0F, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x03, 0x07, 0x0F, 0x0E, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
